# 나쁜 코드
르블랑의 법칙(Leblanc's Law)
**나중은 결코 오지 않는다**. 환자 말대로 따르는 의사는 전문가답지 못하다.
나쁜 코드의 위험을 이해하지 못하는 관리자의 말을 그대로 따르는 행동은 전문가답지 못하다.
- 급하게 서두르며 기능 작성을 하며 만들어진 쓰레기 코드를 차후에 수정하겠다고 판단하고 작성하면, 이후에는 다른 기능을 작성하느라 이전에 작성한 쓰레기 코드를 수정할 시간은 오지 않는다.

## 나쁜 코드로 치르는 대가
나쁜 코드는 개발 속도를 크게 떨어트린다.
- 초반에는 번개처럼 나가더라도 1-2년만에 기어가게 되는 팀도 많다.
- 코드를 고칠 때 마다 엉뚱한 곳에서 버그가 발생한다.
	- 간단한 변경이 없다.
	- 시간이 지날수록 쓰레기 더미는 점점 높아지고 깊어져서 **가독성이 더 떨어지게 된다.**
차후에 기술부채를 치우기 위해 새로운 팀을 만들어 새 시스템으로 작성한다고 해도, 현재 기능과 차후 추가될 기능까지 모두 구현하며 부채를 처리해야하기 때문에 어려움이 남게 된다.

### 태도
환자 말대로 따르는 의사는 전문가답지 못하다. 
나쁜 코드의 위험을 이해하지 못하는 관리자의 말을 그대로 따르는 행동은 전문가잡지 못하다.
`나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 것은 전문가 답지 못하다.`

### 원초적 난제
프로그래머는 근본적인 가치에서 난제에 봉착한다.
1. 나쁜 코드가 업무 속도를 늦춘다는 사실을 익히 안다.
2. 기한을 맞추려면 나쁜 코드를 양산할 수밖에 없다.
→ 빨리 가려고 *(좋은 코드를 작성하기 위해)* 시간을 들이지 않는다.
하지만 나쁜 코드를 양산하면 엉망진찬인 상태로 인해 속도가 늦어지고, 결국 기한을 놓친다.
> 기한을 맞추는 유일한 방법은 언제나 깨끗한 코드를 유지하는 습관이다.

## 깨끗한 코드란?

> 의존성을 최대한 줄여야 유지보수가 쉬워진다.
> 오류는 명백한 전략에 의거해 철저히 처리한다.
> 성능을 최적으로 유지해야 사람들이 원칙 없는 최적화고 코드를 망치려는 유혹에 빠지지 않는다.
> 깨끗한 코드는 한가지를 제대로 한다.
> **비야네 스트롭스트룹 _C++창시자_**

* 창문이 깨진 건물은 누구도 상관하지 않는다. → 창문이 깨지고 나면 쇠퇴하는 과정이 시작된다.
- 꼼꼼하게 코드를 신경써서 오류처리를 제대로 작성한다.
- 깨끗한 코드는 세세한 사항까지 꼼꼼하게 처리하는 코드이다.
- 나쁜 코드는 많은 일을 하려 애쓰다가 의도가 뒤섞이고 목적이 흐려진다.

> 깨끗한 코드는 단순하고 직접적이다.
> 잘 쓴 문장처럼 읽힌다.
> 결코 설계자의 의도를 숨기지 못한다.
> 명쾌한 추상화와 단순한 제어문으로 가득하다.
> **그래디 부치 _Object Oriented Analysis and Design with Application 저자_**

- 깨끗한 코드는 해결할 문제의 긴장을 명확히 드러내야한다.
- 명백한 해법을 제시하며 긴장과 문제를 풀어야한다.
- 반드시 필요한 내용만 담아야한다.
- 코드를 읽는 사람에게 프로그래머가 단호하다는 인상을 줘야한다.

> 깨끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다.
> 단위 테스트 케이스와 인수 테스트 케이스가 존재한다.
> 의미있는 이름이 붙는다.
> 특정 목적을 달성하는 방법은 하나만 제공한다.
> 의존성은 최소이며, 각 의존성을 명확히 정의한다.
> API는 명확하며 최소로 줄였다.
> **데이브 토마스 _OTI 창립자이자 이클립스 전략의 대부_**

- 깨끗한 코드는 `다른 사람`이 고치기 쉽다는게 중요하다.
- 읽기 쉬운 코드와 고치기 쉬운 코드는 엄연히 다르다.
- 테스트 케이스가 없는 코드는 깨끗한 코드가 아니다.
- 아무리 코드가 우아하고, 가독성이 높아도 테스트 케이스가 없으면 깨끗하지않다.
- 큰 코드보다 작은 코드에 더 가치를 둔다.

> 깨끗한 코드는 언제나 주의 깊게 짯다는 느낌을 준다.
> 고치려고 살펴봐도 딱히 손 댈 곳이 없다.
> 작성자가 이미 모든 사항을 고려했으므로, 고칠 궁리를 하다보면 언제나 제자리로 돌아온다.
> **마이클 페더스 _Working Effectively with Legacy Code 저자_**

- 주의 깊게 작성한 코드
- 시간을 들여 깔끔하고 단정하게 정리한 코드
- 세세한 사항까지 꼼꼼하게 신경 쓴 코드
- 주의를 기울인 코드

> 켄트 벡이 제안한 단순한 코드 규칙으로 구현을 시작한다.
> 모든 테스트를 통과한다.
> 중복이 없다.
> 시스템 내 모든 설계 아이디어를 표현한다.
> 클래스, 메서드, 함수 등을 최대한 줄인다.
> **론 제프리스 _Extreme Programming Installed과 Extreme Programming Adventure in C#저자_**
- 같은 작업을 여러차례 반복한다면, 코드가 아이디어를 제대로 표현하지 못 한다는 증거다.
- 표현력은 의미있는 이름을 포함한다.
	- 확정하기 전에 이름을 여러차례 바꾼다.
- 객체가 여러 기능을 수행한다면 여러 객체로 나눈다.
- 메서드가 여러 기능을 수행한다면 메서드 추출 _Extract Method_ 리팩터링 기법을 적용해 기능을 명확히 기술하는 메서드 하나와 기능을 실제로 수행하는 메서드 여러개로 나눈다.
- 중복과 표현력만 신경써도 깨끗한 코드라는 목표에 다가선다.
- 기능의 공통점을 발견하고 코드를 추상화하고, 추상 메서드에서 제공하는 기능을 사용해 실제 구현을 언제든지 바꾼다. 간단하게 재빨리 구현했다가, 나중에 필요하면 바꾼다.
- 중복 줄이기, 표현력 높이기, 초반부터 간단한 추상화 고려하기, 이 세가지가 깨끗한 코드를 만드는 비결이다.

> 코드를 읽으면 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다.
> 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다.
> **워드 커닝햄 _위키 창시자, 피트 창시자, 익스트림 프로그래밍 공동 창시자_**

- 깨끗한 코드를 읽으면서 놀랄 일이 없어야 한다.
- 코드를 독해하느라 머리를 쥐어짤 필요가 없어야 한다.
- 프로그램을 단순하게 보이는 열쇠는 언어가 아니다. 언어를 단순하게 보이도록 만으는 열쇠는 프로그래머다.

## 보이스카우트 규칙
잘 짠 코드가 전부는 아니다. 시간이 지나도 언제나 깨끗하게 유지해야한다.
시간이 지나면서 엉망으로 전락하는 코드가 한둘이 아니다. 그러므로 우리는 적극적으로 코드의 퇴보를 막아야한다.
`캠프장은 처음 왔을 때 보다 더 깨끗하게 해놓고 떠나라`

체크아웃을할 떄보다 좀 더 깨끗한 코드를 체크인한다면 코드는 절대 나빠지지 않는다.

### 깨끗한 코드에 대한 정리
1. 나쁜 코드는 개발 속도를 크게 떨어트린다
2. 의존성을 최대한 줄여야 한다.
3. 오류는 명백한 전략에 의거해 철저히 처리한다.
	-  깨끗한 코드는 세세한 사항까지 꼼꼼하게 처리하는 코드이다.
4. 깨끗한 코드는 한가지를 제대로 한다.
5. 깨끗한 코드는 단순하고 직접적이다.
6. 깨끗한 코드는 반드시 필요한 내용만 담아야한다.
7. 깨끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다.
8. 테스트 케이스가 없는 코드는 깨끗한 코드가 아니다.
9. 깨끗한 코드는 의미있는 이름이 붙는다.
10. 큰 코드보다 작은 코드에 더 가치를 둔다.
11. 깨끗한 코드는 중복이 없다.
12. 클래스, 메서드, 함수 등을 최대한 줄인다.
13. 잘 짠 코드가 전부는 아니다. 시간이 지나도 언제나 깨끗하게 유지해야한다.

- 함수는 하나의 기능만 구현하며, 단순하게 작성한다.
- 가독성이 좋게 의미있는 이름을 사용
- 모든 문제는 작은 코드로 쪼개서 해결
- 중복을 최대한 줄이고 클래스, 메서드, 함수 등을 최대한 줄인다.
- 최대한 꼼꼼하고 세세하게 오류처리한다.